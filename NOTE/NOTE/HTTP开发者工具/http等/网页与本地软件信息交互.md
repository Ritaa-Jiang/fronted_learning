为什么网页可以调取我在电脑上使用的软件的信息，比如网页可以识别到我的电脑是否已经登录了qq/微信，这个过程中经历了什么 什么协议 传输了什么信息



### 一、核心原理：URI 协议检测（判断应用是否存在）



当网页想知道你是否安装了 QQ / 微信时，会尝试触发**自定义 URI 协议**（如 `qq://` 或 `weixin://`）：



1. **网页发起请求**：通过 `<a href="qq://">` 或 JavaScript 的 `window.open('weixin://')` 尝试唤醒本地应用。

2. 浏览器拦截与反馈

   ：

   - 若电脑未安装 QQ / 微信，浏览器会提示 “无法打开链接”，网页通过**超时机制**（如 300ms 内无响应）判断应用不存在。
   - 若已安装，浏览器会询问是否打开应用，网页通过**监听协议调用的返回状态**（如 `beforeunload` 事件）间接确认应用存在。
   - **注意**：这种方式只能检测应用是否安装，**无法直接获取登录状态**，需配合后续授权流程。

### 二、深度交互：OAuth2.0 授权（获取登录状态）



当网页需要确认你是否已登录（如 “QQ 快捷登录”），会触发**OAuth2.0 授权流程**，典型步骤如下：



1. **网页跳转授权页**：
   网页跳转至 `https://graph.qq.com/oauth2.0/authorize`（QQ 授权端点），携带 `client_id`（网页身份）和 `redirect_uri`（回调地址）。
2. **本地应用捕获请求**：
   若 QQ 已登录，电脑端 QQ 会拦截此请求（通过注册的 URI 协议或本地服务），**自动填充登录态**，避免用户重复输入密码。
3. **授权码返回**：
   QQ 服务器向网页回调地址发送 `code`（临时授权码），网页用 `code` 换取 `access_token`（访问令牌）。
4. **验证登录状态**：
   网页通过 `access_token` 调用 QQ 接口（如 `userinfo`），获取用户 ID、头像等信息，确认已登录。



**协议与传输内容**：



- 协议：HTTPS（防止中间人攻击）、OAuth2.0（授权标准）。
- 关键数据：加密的 `code` 和 `access_token`（无明文密码），用户 ID（脱敏）。
- 安全设计：`redirect_uri` 需提前在 QQ 开放平台备案，防止 CSRF 攻击。

### 三、微信网页版的特殊机制：本地服务监听



微信网页版（如 `wx.qq.com`）依赖**独立的本地服务**实现登录状态同步：



1. **用户主动扫码**：
   网页显示二维码，用户用微信 APP 扫码，此时 APP 向电脑端微信发送 “确认登录” 指令。
2. **本地服务通信**：
   电脑端微信运行 `WeChatWin.dll` 等组件，监听本地端口（如 `127.0.0.1:随机端口`），通过**WebSocket**与网页通信。
3. **状态同步**：
   网页通过本地服务获取用户头像、昵称等信息，确认登录，但**无法直接读取聊天记录**（需二次授权）。



**协议与传输内容**：



- 协议：WebSocket（`ws://` 或 `wss://`）、HTTP。
- 数据：加密的 JSON 数据包（含用户 ID、设备指纹），通过 AES 或微信自研算法加密。
- 权限控制：必须用户扫码确认，网页无权限主动唤醒微信。

### 四、关键安全边界



1. **用户主动触发**：所有交互需用户点击 “登录”“扫码” 等操作，网页无法静默窃取信息。
2. **最小权限原则**：QQ / 微信仅返回头像、昵称等基础信息，敏感数据（如聊天记录）需单独授权。
3. **浏览器限制**：同源策略禁止跨站调用协议，且自定义协议需用户手动允许（如首次打开 QQ 时的 “始终允许” 弹窗）。
4. **本地应用防护**：QQ / 微信通过签名校验、进程守护防止恶意程序伪造登录态。

### 五、总结：从 “检测存在” 到 “确认登录” 的完整链路



1. **URI 协议检测**（粗粒度）：网页试探应用是否安装。
2. **OAuth 授权**（中粒度）：用户主动授权后，网页通过令牌确认登录。
3. **本地服务直连**（细粒度）：微信等应用通过专属协议实现状态同步。



整个过程中，**用户始终是授权主体**，网页无法突破浏览器和本地应用的安全沙盒。若担心隐私泄露，可通过浏览器禁用自定义协议（如 Chrome 的 `chrome://settings/handlers`）或退出电脑端应用。